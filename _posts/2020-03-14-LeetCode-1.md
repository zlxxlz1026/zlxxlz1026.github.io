---
layout: post
title: 'LeetCode 1'
subtitle: '动态规划 完全二叉树'
date: 2020-03-14
categories: 算法
tags: LeetCode
---

## 221.最大正方形

![](https://github.com/zlxxlz1026/MyPicture/blob/master/LeetCode%E2%80%94%E2%80%941/1.png?raw=true)

先来阐述简单共识

若形成正方形（非单 1），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 1
可以换个角度：当前格、上、左、左上都不能受 0 的限制，才能成为正方形

![](https://github.com/zlxxlz1026/MyPicture/blob/master/LeetCode%E2%80%94%E2%80%941/4.jpg?raw=true)


上面详解了 三者取最小 的含义：

图1：受限于左上的0
图2：受限于上边的0
图3：受限于左边的0
数字表示：以此为正方形右下角的最大边长
黄色表示：格子 ? 作为右下角的正方形区域
就像 木桶的短板理论 那样——附近的最小边长，才与 ? 的最长边长有关。
此时已可得到递推公式  :$$if (grid[i][j] == 1) f[i][j] = min(f[i-1][j-1], f[i-1][j], f[i][j-1]) + 1;$$ 

代码如下：

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int maxside=0;
        if(matrix.size()==0||matrix[0].size()==0)
            return 0;
        int **dp = new int*[matrix.size()+1]();
        for(int i=0;i<matrix.size()+1;i++)
            dp[i] = new int[matrix[0].size()+1]();
        for(int i=0;i<matrix.size();i++)
            for(int j=0;j<matrix[0].size();j++){
                if(matrix[i][j]=='1'){
                    dp[i+1][j+1] = min(min(dp[i][j+1],dp[i+1][j]),dp[i][j])+1;
                    maxside = max(maxside,dp[i+1][j+1]);
                }
            }
        return maxside*maxside;
    }
};
```

